// === Modified CUDA Code for 2 GPUs (Maintaining Same Functions) ===
// This version splits image rows between two GPUs and processes them in parallel

#include <iostream>
#include <numeric>
#include <stdlib.h>
#include <stdio.h>
#include <cuda_runtime.h>
#include <sys/time.h>

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

using namespace std;

unsigned char *image;
int width, height, pixelWidth;

// Kernel declarations (same as provided)
__global__ void rgb2ycbcr_rowwise(unsigned char* d_image, unsigned int* d_hist, int width, int height);
__global__ void blur_Y_channel(unsigned char* d_image, unsigned char* d_blurred, int width, int height);
__global__ void histogram_shared(unsigned char* d_image, unsigned int* d_hist, int width, int height);
__global__ void equalize_and_reconstruct_rowwise(unsigned char* d_image, int* d_cdf, int width, int height);

// Helper: set CUDA device, launch kernels on image segment
void process_segment_on_gpu(int device_id, unsigned char* host_image_segment, int width, int height_segment) {
    cudaSetDevice(device_id);
    int image_size = width * height_segment * pixelWidth;

    unsigned char *d_image, *d_blurred;
    unsigned int* d_hist;

    cudaMalloc(&d_image, image_size);
    cudaMemcpy(d_image, host_image_segment, image_size, cudaMemcpyHostToDevice);
    cudaMalloc(&d_blurred, image_size);
    cudaMalloc(&d_hist, 256 * sizeof(unsigned int));
    cudaMemset(d_hist, 0, 256 * sizeof(unsigned int));

    dim3 block(32, 32);
    dim3 grid((width + block.x - 1) / block.x, (height_segment + block.y - 1) / block.y);

    rgb2ycbcr_rowwise<<<grid, block>>>(d_image, d_hist, width, height_segment);
    blur_Y_channel<<<grid, block>>>(d_image, d_blurred, width, height_segment);
    cudaMemcpy(d_image, d_blurred, image_size, cudaMemcpyDeviceToDevice);

    cudaMemset(d_hist, 0, 256 * sizeof(unsigned int));
    histogram_shared<<<grid, block>>>(d_image, d_hist, width, height_segment);

    unsigned int h_hist[256] = {0};
    cudaMemcpy(h_hist, d_hist, 256 * sizeof(unsigned int), cudaMemcpyDeviceToHost);
    int h_cdf[256] = {0}, sum = 0;
    for (int i = 0; i < 256; i++) {
        sum += h_hist[i];
        h_cdf[i] = (int)((((float)sum - h_hist[0]) / ((float)(width * height_segment - 1))) * 255);
    }

    int* d_cdf;
    cudaMalloc(&d_cdf, 256 * sizeof(int));
    cudaMemcpy(d_cdf, h_cdf, 256 * sizeof(int), cudaMemcpyHostToDevice);

    equalize_and_reconstruct_rowwise<<<grid, block>>>(d_image, d_cdf, width, height_segment);
    cudaMemcpy(host_image_segment, d_image, image_size, cudaMemcpyDeviceToHost);

    cudaFree(d_image);
    cudaFree(d_blurred);
    cudaFree(d_hist);
    cudaFree(d_cdf);
}

int main(int argc, char** argv) {
    cudaFree(0);
    const char* input = "./IMG/IMG00.jpg";
    const char* output = "output_equalized_gpu2.png";

    int n_channels;
    unsigned char* raw = stbi_load(input, &width, &height, &n_channels, 0);
    if (!raw) {
        fprintf(stderr, "‚ùå Couldn't load image.\n");
        return -1;
    }

    pixelWidth = n_channels;
    int size = width * height * pixelWidth;
    cudaHostAlloc((void**)&image, size, cudaHostAllocDefault);
    memcpy(image, raw, size);
    stbi_image_free(raw);

    printf("Loaded image: %s (%d x %d, Channels: %d)\n", input, width, height, pixelWidth);

    // Split image vertically
    int h_half = height / 2;
    unsigned char* img_top = image;
    unsigned char* img_bottom = image + (h_half * width * pixelWidth);

    struct timeval start, end;
    gettimeofday(&start, NULL);

    // Launch 2 threads (for 2 GPUs)
    #pragma omp parallel num_threads(2)
    {
        int tid = omp_get_thread_num();
        if (tid == 0) process_segment_on_gpu(0, img_top, width, h_half);
        else process_segment_on_gpu(1, img_bottom, width, height - h_half);
    }

    gettimeofday(&end, NULL);
    double total_time = (end.tv_sec - start.tv_sec) * 1000.0 + (end.tv_usec - start.tv_usec) / 1000.0;
    printf("Total 2-GPU Execution Time: %.3f ms\n", total_time);

    stbi_write_png(output, width, height, pixelWidth, image, 0);
    cudaFreeHost(image);

    return 0;
}
